% filename GenericSettings.Rnw 



% filename DataEntry001.Rnw 

%\setcounter{chapter}{} 
\chapter{LURN\ldots{} To Enter Data} 
\label{DataEntry} 
 
% filename DataEntry003.Rnw 

 
The purpose of this chapter is to show the novice \R{} user how \R{} stores data by introducing the shortcuts that make data entry a fairly simple task. 
 
Entering screeds of data is not fun in any software tool. It's more common for the \R{} user to have the data they need already available from another source. This is covered in Chapter~\ref{ImportData} on importing data from alternate sources. 
 
Of course, if you really must enter data manually then you'd better read on; we can at least try to make it as painless as possible. 
 
\section{Using \R{} as a simple calculator} 
\label{SimpleCalculator} 
 
\R{} can be used to do basic operations whose results do not get stored as objects. We can also assign the answers to a variable. For example 
% filename DataEntry004.Rnw 

\begin{Schunk}
\begin{Sinput}
> x=100/7 
> x 
\end{Sinput}
\begin{Soutput}
[1] 14.29
\end{Soutput}
\end{Schunk}
% filename DataEntry005.Rnw 

This means we can use the variable by name later. For example 
% filename DataEntry006.Rnw 

\begin{Schunk}
\begin{Sinput}
> 12*x 
\end{Sinput}
\begin{Soutput}
[1] 171.4
\end{Soutput}
\end{Schunk}
% filename DataEntry007.Rnw 

 
We can also use some basic mathematical functions such as the logarithm and square root via the \Rcmd{log} and \Rcmd{sqrt} commands --- many other commands like this exist! For example 
% filename DataEntry008.Rnw 

\begin{Schunk}
\begin{Sinput}
> x=sqrt(169) 
> y=log(500) 
> x*y 
\end{Sinput}
\begin{Soutput}
[1] 80.79
\end{Soutput}
\end{Schunk}
% filename DataEntry009.Rnw 

OK, these manipulations are trivial, but they can be used in conjunction with other data objects as we will see later. More detail on how to use \R{} as a scientific calculator can be found in Chapter~\ref{ScientificCalculator}. 
 
 
\section{A simple set of numbers} 
 
Operating on single values is rare. We are usually faced with numbers that we wish to use as a set. Entering them as a set is therefore necessary. The most basic way of entering a set of numbers is using the \Rcmd{c} command. For example 
% filename DataEntry010.Rnw 

\begin{Schunk}
\begin{Sinput}
> y=c(1, 4, 9, 16, 25, 36, 49, 64, 81, 100) 
> y 
\end{Sinput}
\begin{Soutput}
 [1]   1   4   9  16  25  36  49  64  81 100
\end{Soutput}
\end{Schunk}
% filename DataEntry011.Rnw 

is the list of the squares of the first ten natural numbers. We can obtain the numbers from 1 to 10 faster by issuing 
% filename DataEntry012.Rnw 

\begin{Schunk}
\begin{Sinput}
> x=1:10 
> x 
\end{Sinput}
\begin{Soutput}
 [1]  1  2  3  4  5  6  7  8  9 10
\end{Soutput}
\end{Schunk}
% filename DataEntry013.Rnw 

and therefore can obtain the desired set of the squares for the first ten natural numbers using shorter code based on a simple sequence. 
% filename DataEntry014.Rnw 

\begin{Schunk}
\begin{Sinput}
> y=(1:10)^2 
> y 
\end{Sinput}
\begin{Soutput}
 [1]   1   4   9  16  25  36  49  64  81 100
\end{Soutput}
\end{Schunk}
% filename DataEntry015.Rnw 

This is much more efficient than typing out the actual results as done previously. Note that the colon symbol is used for generating series of integers and that in terms of the order of mathematical operators, it comes after the exponent; the brackets around the sequence are essential. In this case, squaring a number is achieved through use of the carat symbol followed by a 2.  
 
 
\section{A simple set of text values} 
 
The \Rcmd{c} command is good for entering any kind of data. We may need to enter a set of categories for example. 
% filename DataEntry016.Rnw 

\begin{Schunk}
\begin{Sinput}
> Names = c("Jonathan", "Elizabeth", "Peter", "Jenna", "Callum", "Annabelle", "Cordelia") 
> Names 
\end{Sinput}
\begin{Soutput}
[1] "Jonathan"  "Elizabeth" "Peter"     "Jenna"    
[5] "Callum"    "Annabelle" "Cordelia" 
\end{Soutput}
\end{Schunk}
% filename DataEntry017.Rnw 

Note two important features of this command. I capitalized the variable name here on purpose. The vast majority of \R{} commands are in lower case and there is one called ``names". I don't want to confuse my data and an existing \R{} command so my preference is to use an upper case letter on the front of all my variable names that mean anything. The second point is that the character-valued data I entered were encapsulated by quote marks. This means that the actual names (mine, my last dog and some family members) were stored. If I had omitted the quote marks, \R{} would have looked for variables with the appropriate names --- not defined in this instance. You could remove a quote or two to see what happens if you must. 
 
\section{Logical indicators} 
 
\R{} often uses logical indicators to tell us something. These variables take the values ``\code{TRUE}" or ``\code{FALSE}". 
 
% filename DataEntry018.Rnw 

\begin{Schunk}
\begin{Sinput}
> Human = c(TRUE, TRUE, TRUE, FALSE, TRUE, TRUE, TRUE) 
\end{Sinput}
\end{Schunk}
% filename DataEntry019.Rnw 

You might suspect that this variable tells you if the name given in the \Robject{Names} variable are for humans. The fourth name is therefore the dog. To extract the names of the humans we use the command 
% filename DataEntry020.Rnw 

\begin{Schunk}
\begin{Sinput}
> Names[Human] 
\end{Sinput}
\begin{Soutput}
[1] "Jonathan"  "Elizabeth" "Peter"     "Callum"   
[5] "Annabelle" "Cordelia" 
\end{Soutput}
\end{Schunk}
% filename DataEntry021.Rnw 

Note here that the brackets used are square brackets. Use round brackets for functions, square for elements of an object. 
 
It's pretty simple to extract the dog's name: 
% filename DataEntry022.Rnw 

\begin{Schunk}
\begin{Sinput}
> Names[!Human] 
\end{Sinput}
\begin{Soutput}
[1] "Jenna"
\end{Soutput}
\end{Schunk}
% filename DataEntry023.Rnw 

In this situation the exclamation mark should be read as ``not" and therefore picks up the elements where the logical variable is set to \code{FALSE}. 
 
\section{A note on subscripting} 
 
We've seen that we can find a subset of the set of names using the indicator variable, but it's frequently useful to be able to extract one or more elements by their location. For example 
% filename DataEntry024.Rnw 

\begin{Schunk}
\begin{Sinput}
> Names[1] 
\end{Sinput}
\begin{Soutput}
[1] "Jonathan"
\end{Soutput}
\end{Schunk}
% filename DataEntry025.Rnw 

gives the first name, and  
% filename DataEntry026.Rnw 

\begin{Schunk}
\begin{Sinput}
> Names[2:3] 
\end{Sinput}
\begin{Soutput}
[1] "Elizabeth" "Peter"    
\end{Soutput}
\end{Schunk}
% filename DataEntry027.Rnw 

extracts the second and third names. The set of names entered is a \Rclass{vector} and has only one subscript to monitor. We will see how to subscript elements within a \Rclass{matrix} or \Rclass{data.frame} later. 
 
It's also often necessary to understand how \R{} has stored an object. The \Rcmd{class} command is useful, and so is the \Rcmd{str} command. For example 
% filename DataEntry028.Rnw 

\begin{Schunk}
\begin{Sinput}
> class(Names) 
\end{Sinput}
\begin{Soutput}
[1] "character"
\end{Soutput}
\begin{Sinput}
> str(Names) 
\end{Sinput}
\begin{Soutput}
 chr [1:7] "Jonathan" "Elizabeth" "Peter" "Jenna" ...
\end{Soutput}
\end{Schunk}
% filename DataEntry029.Rnw 

We can get the names of all the people that aren't me by 
% filename DataEntry030.Rnw 

\begin{Schunk}
\begin{Sinput}
> Names[-1] 
\end{Sinput}
\begin{Soutput}
[1] "Elizabeth" "Peter"     "Jenna"     "Callum"   
[5] "Annabelle" "Cordelia" 
\end{Soutput}
\end{Schunk}
% filename DataEntry031.Rnw 

which of course assumes you know my name was given first. The subscripts have used square brackets in these examples. The type (and number) of brackets is crucial. If you open a bracket it must be closed, and closed by a bracket of the same type. Nesting brackets is quite acceptable. 
 
 
\section{A patterned set of numbers} 
 
In many instances we need to generate series of values in a patterned way. Let's say we want to generate variables that represent the twenty working days over a four week period. We want a list of the week number, and then a list of the weekday names. In both situations we will use the \Rcmd{rep} command. It has three arguments; the list of values, the number of times \Rarg{each} value is to be repeated, and the number of \Rarg{times} the whole series should be repeated.  
The second and third of these arguments have default values so may not need to be stated explicitly. 
% filename DataEntry032.Rnw 

\begin{Schunk}
\begin{Sinput}
> Week = rep(1:4, each=5) 
> Week 
\end{Sinput}
\begin{Soutput}
 [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 4 4 4 4 4
\end{Soutput}
\begin{Sinput}
> Day = rep(c("Mon", "Tue", "Wed", "Thu", "Fri"), times=4) 
> Day 
\end{Sinput}
\begin{Soutput}
 [1] "Mon" "Tue" "Wed" "Thu" "Fri" "Mon" "Tue" "Wed" "Thu"
[10] "Fri" "Mon" "Tue" "Wed" "Thu" "Fri" "Mon" "Tue" "Wed"
[19] "Thu" "Fri"
\end{Soutput}
\end{Schunk}
% filename DataEntry033.Rnw 

These two variables can be brought together with the corresponding data using the \Rcmd{data.frame} command illustrated later in this chapter. 
 
\section{Less pattern and more repetition} 
 
The \Rcmd{rep} command is very flexible, and to be honest can either be a lot of fun to play with or just one big headache. Let's say we want to generate the series of numbers which has one 1, two 2's, three 3's, four 4's, and five 5's. Instead of using the constant for the number of times each element is repeated, we can choose the number of repeats for each element. 
% filename DataEntry034.Rnw 

\begin{Schunk}
\begin{Sinput}
> rep(1:5, times=1:5) 
\end{Sinput}
\begin{Soutput}
 [1] 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5
\end{Soutput}
\end{Schunk}
% filename DataEntry035.Rnw 

Whatever you do you should observe the way your series is coming out. I would have expected the \Rarg{each} to be used in the last example not \Rarg{times} for example --- always check. 
 
\section{An incomplete pattern} 
 
Let's say we want a set of numbers to be cycled, but know that we won't use the full cycle. The \Rcmd{rep} has an argument that can stop the process early for us. Try using the \Rarg{length.out} argument as follows 
% filename DataEntry036.Rnw 

\begin{Schunk}
\begin{Sinput}
> rep(c(1,2,4), times=3, length.out=8) 
\end{Sinput}
\begin{Soutput}
[1] 1 2 4 1 2 4 1 2
\end{Soutput}
\end{Schunk}
% filename DataEntry037.Rnw 

 
 
\section{Dates and times} 
 
The current time and date can be extracted using the \Rcmd{date} command but this is not an object that can be manipulated --- it is a character string only. 
% filename DataEntry038.Rnw 

\begin{Schunk}
\begin{Sinput}
> date() 
\end{Sinput}
\begin{Soutput}
[1] "Thu Aug 24 15:37:22 2017"
\end{Soutput}
\begin{Sinput}
> class(date()) 
\end{Sinput}
\begin{Soutput}
[1] "character"
\end{Soutput}
\end{Schunk}
% filename DataEntry039.Rnw 

It might be useful to print this information as part of your documentation of an analysis. We can come back to an \R{} session at a later time and to keep track of when we do things might prove useful. You can see from the output given here the exact time and date this document was compiled. This format is not to be confused with what we would store or manipulate; it is just a print out of the current time and date. The \Rcmd{Sys.Date} command stores the same information as number. 
% filename DataEntry040.Rnw 

\begin{Schunk}
\begin{Sinput}
> Sys.Date() 
\end{Sinput}
\begin{Soutput}
[1] "2017-08-24"
\end{Soutput}
\begin{Sinput}
> class(Sys.Date()) 
\end{Sinput}
\begin{Soutput}
[1] "Date"
\end{Soutput}
\end{Schunk}
% filename DataEntry041.Rnw 

 
This print out is different to what needs to happen when we want to store numerical values that represent the times and dates particular observations were taken. The base distribution of \R{} does not cater for extracting the date and time in simple numeric terms. This can be achieved, but is beyond the scope of this chapter. It may prove best to store a date using its three constituent parts (day, month, and year) as separate numeric variables. Times should be stored using 24-hour format and be careful not to use a separator between the hour and minute values. Mathematical operations should not be done on these variables unless we convert the minutes to decimal fractions of an hour. In any situation you should decide what you will do with the data before choosing the format you wish to store it in. 
 
An example for storing details of months might be useful here. 
% filename DataEntry042.Rnw 

\begin{Schunk}
\begin{Sinput}
> Months = as.factor(c(3,6,9,12,3,6,9,12)) 
> Months 
\end{Sinput}
\begin{Soutput}
[1] 3  6  9  12 3  6  9  12
Levels: 3 6 9 12
\end{Soutput}
\end{Schunk}
% filename DataEntry043.Rnw 

The \Rcmd{as.factor} command tells \R{} that these numbers are to be thought of as non-numeric data. A \Rclass{factor} also has an associated attribute called \Rarg{levels}. We can edit the levels directly and this will change our entire variable. \label{UseOfLevels} 
% filename DataEntry044.Rnw 

\begin{Schunk}
\begin{Sinput}
> levels(Months) = c("Mar", "Jun", "Sep", "Dec") 
> Months 
\end{Sinput}
\begin{Soutput}
[1] Mar Jun Sep Dec Mar Jun Sep Dec
Levels: Mar Jun Sep Dec
\end{Soutput}
\end{Schunk}
% filename DataEntry045.Rnw 

As it happens, we didn't need to actually explicitly state the month number when the variable was first created, but it is good practice to keep things logical! 
 
\section{Larger data objects} 
 
There are two data object types that are quite similar but not the same. A \Rclass{matrix} is a two-dimensional array of values of the same type --- numeric, character, or logical. A \Rclass{data.frame} looks like a matrix but can have variables of different types embedded within it. For example, we can create a new \Rclass{data.frame} by combining the names and human status variables created earlier using 
% filename DataEntry046.Rnw 

\begin{Schunk}
\begin{Sinput}
> data.frame(Names, Human) 
\end{Sinput}
\begin{Soutput}
      Names Human
1  Jonathan  TRUE
2 Elizabeth  TRUE
3     Peter  TRUE
4     Jenna FALSE
5    Callum  TRUE
6 Annabelle  TRUE
7  Cordelia  TRUE
\end{Soutput}
\end{Schunk}
% filename DataEntry047.Rnw 

We would usually assign the results of this command to a named object for storage. 
% filename DataEntry048.Rnw 

\begin{Schunk}
\begin{Sinput}
> MyFirstDF = data.frame(Names, Human) 
> str(MyFirstDF) 
\end{Sinput}
\begin{Soutput}
'data.frame':	7 obs. of  2 variables:
 $ Names: Factor w/ 7 levels "Annabelle","Callum",..: 6 4 7 5 2 1 3
 $ Human: logi  TRUE TRUE TRUE FALSE TRUE TRUE ...
\end{Soutput}
\end{Schunk}
% filename DataEntry049.Rnw 

 
Now we can see why we should not confuse \code{names} and \Robject{Names}. We can ask for the names of the variables in a \Rclass{data.frame} using the \Rcmd{names} command. For example 
% filename DataEntry050.Rnw 

\begin{Schunk}
\begin{Sinput}
> names(MyFirstDF) 
\end{Sinput}
\begin{Soutput}
[1] "Names" "Human"
\end{Soutput}
\end{Schunk}
% filename DataEntry051.Rnw 

 
We can also now think about how we might extract the fourth name from the \Rclass{data.frame} because this is the data structure we will work with the most. There are several alternatives. 
% filename DataEntry052.Rnw 

\begin{Schunk}
\begin{Sinput}
> MyFirstDF[4,1] 
\end{Sinput}
\begin{Soutput}
[1] Jenna
7 Levels: Annabelle Callum Cordelia Elizabeth ... Peter
\end{Soutput}
\begin{Sinput}
> MyFirstDF[4,"Names"] 
\end{Sinput}
\begin{Soutput}
[1] Jenna
7 Levels: Annabelle Callum Cordelia Elizabeth ... Peter
\end{Soutput}
\begin{Sinput}
> MyFirstDF$Names[4] 
\end{Sinput}
\begin{Soutput}
[1] Jenna
7 Levels: Annabelle Callum Cordelia Elizabeth ... Peter
\end{Soutput}
\end{Schunk}
% filename DataEntry053.Rnw 

 
Notice that as well as the result we wanted, \R{} has also printed the levels of the \Robject{Names} variable. This is because this variable has been determined to be a factor. 
 
 
 
\section{Appropriate data labelling} 
 
The construction of our first data.frame is slightly flawed. If the \Robject{MyFirstDF} data was going to be for all those beings I am in contact with, the details should be related to the individual concerned. In this situation, allowing the \Robject{Names} object to be data rather than a label was probably not the wisest move. Let's say that we want the year and month of birth for the individuals in the example, and that they should form a new \Rclass{data.frame}. 
% filename DataEntry054.Rnw 

\begin{Schunk}
\begin{Sinput}
> Year = c(1971, 1945, 1925, 2003, 2010, 2012, 2013) 
> Month = c("October", "October", "July", "October", "April", "June", "June") 
> MySecondDF = data.frame(Year, Month, Human, row.names = Names) 
> str(MySecondDF) 
\end{Sinput}
\begin{Soutput}
'data.frame':	7 obs. of  3 variables:
 $ Year : num  1971 1945 1925 2003 2010 ...
 $ Month: Factor w/ 4 levels "April","July",..: 4 4 2 4 1 3 3
 $ Human: logi  TRUE TRUE TRUE FALSE TRUE TRUE ...
\end{Soutput}
\end{Schunk}
% filename DataEntry055.Rnw 

 
\section{Other approaches} 
 
Data entry is tedious. Efficiency is therefore an important weapon in your armoury. When we plan experiments we are often interested in obtaining an observation (or multiple observations) for every combination of some factors. In this simple example, imagine there are three experimental factors, given the names H, W, and Sex, and that each factor can take either of two levels. The \Rcmd{expand.grid} command is a useful way to construct a \Rclass{data.frame}. 
% filename DataEntry056.Rnw 

\begin{Schunk}
\begin{Sinput}
> MyThirdDF = expand.grid(h=c(60,80), w=c(100, 300), sex=c("Male", "Female")) 
> MyThirdDF 
\end{Sinput}
\begin{Soutput}
   h   w    sex
1 60 100   Male
2 80 100   Male
3 60 300   Male
4 80 300   Male
5 60 100 Female
6 80 100 Female
7 60 300 Female
8 80 300 Female
\end{Soutput}
\end{Schunk}
% filename DataEntry057.Rnw 

 
I've used a full printout of the resulting \Rclass{data.frame} instead of using the \Rcmd{str} command to show what \R{} has created because the \Rcmd{str} command gives additional information that we do not require at this point. 
 
Let's say we wish to add a new variable to this \Rclass{data.frame}; a task common when designing an experiment. We can use the \$ notation shown earlier in a new way. We add a set of eight random values extracted from a standard normal distribution here as an illustration using the \Rcmd{rnorm} function. 
% filename DataEntry058.Rnw 

\begin{Schunk}
\begin{Sinput}
> MyThirdDF$Response = rnorm(8) 
> MyThirdDF 
\end{Sinput}
\begin{Soutput}
   h   w    sex Response
1 60 100   Male -0.53954
2 80 100   Male  0.09504
3 60 300   Male  0.16238
4 80 300   Male -0.40040
5 60 100 Female  0.07082
6 80 100 Female  0.06128
7 60 300 Female  0.22646
8 80 300 Female -0.66805
\end{Soutput}
\end{Schunk}
% filename DataEntry059.Rnw 

 
I like to create random data when planning an analysis. In this instance, the data are normally distributed which is not particularly important, but they are random which is important. There are many other functions that generate random data from other distributions; by convention, these functions all start with a letter ``r" followed by a shortened form of the distribution's name.  
 
I do this because data that will  be collected should be appropriate for the intended analysis to be conducted, and likewise the analysis should reflect the way data were collected. Creation of the random data means I can write the \R{} commands that will generate the analysis, and once I have checked that the analysis is possible, I can then collect the data. When the data has been collected, I can then re-process the commands using the real data instead of the  random data. This can save time during the analysis but more importantly, I can be confident that the data collection and analysis were planned well. 
 
 
% filename CleanUp.Rnw 



