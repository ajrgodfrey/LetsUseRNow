%\setcounter{chapter}{} 
% commands to check for inclusion 
% filter(), HoltWinters(), spectrum(), Box.test(), lag.plot(), monthplot(), tsdiag(),  
\chapter{LURN\ldots{} To Perform Times Series Analyses} 
\label{TimeSeries} 
 
<<setup, include=FALSE>>= 
opts_chunk$set(fig.path='figures/TimeSeries', comment=NA, dev=c('pdf','postscript','svg'), prompt=T, out.width="0.7\\textwidth") 
source("GenericSettings.R") 
@ 
 
This chapter focuses on some simple time series approaches for univariate time series. At this stage multivariate time series are not included, but could be in future depending on demand. In any case, the methods shown here are certainly not meant to be a comprehensive elucidation of all time series methods. Dealing with just the most commonly taught (and therefore the simplest) methods takes up enough space.  
 
You will need to refer to a standard time series analysis textbook for more complete guidance; many of these are now written with \R{} as the chosen software to support the material in the book. 
 
Given this proliferation of textbooks on the topic of time series analysis, it is no surprise that there are a number of add-on packages written to support them. In this chapter we do not extend beyond the functionality offered by the base distribution of \R{}. 
 
\section{Time series objects in \R{}} 
 
The basic univariate time series, with no missing data is stored in \R{} as a time series object. This is marginally different to a vector in that it has a time stamp or index associated with each observation in the series. 
 
We will use several time series data sets that are available within the default installation of \R{}.  
<<IntroData>>= 
str(LakeHuron) 
str(lynx) 
str(Nile) 
@ 
The first is for the level of Lake Huron; the second is the number of lynx that were trapped in Canada; and the third is the flow of the River Nile. More detailed information for all of these series is available using the relevant help function for the series. 
 
You can use the Rcmd{as.ts} command to convert a vector of observations to a time series object. For example, the Robject{airquality} data is recorded in time order. We might want to treat the observed temperatures as a time series by converting it using: 
<<MakeTSTemp>>= 
Temp.ts = as.ts(airquality$Temp) 
@ 
 
\section{Time series plots} 
 
We have seen the flexibility of the \Rcmd{plot} command in previous chapters, and now we see another use. Applying the \Rcmd{plot} command to a time series object generates a time series plot, as seen in Exhibit~\ref{NileTSPlot}. 
\begin{exhibit} 
\begin{center} 
\caption{Time series plot for the annual flow of the River Nile.} 
\label{NileTSPlot} 
<<NilePlot, fig=TRUE>>= 
plot(Nile, xlab="Year", ylab="Flow") 
@ 
\SVGLink{TimeSeriesNilePlot-1} 
\end{center} 
\end{exhibit} 
%%%check resulting graph and fix 
 
Having the class assigned to our data means the plot was enhanced slightly. Check this by comparing the results for the two plots in Exhibit~\ref{TSPlotsCompared}. 
\begin{exhibit} 
\begin{center} 
\caption{Comparison of use of \Rcmd{plot} on a vector and a time series object.} 
\label{TSPlotsCompared} 
<<TSPlotsCompared, fig=TRUE>>= 
plot(airquality$Temp, ylab="Temperature") 
plot(Temp.ts, ylab="Temperature") 
@ 
\SVGLink{TSPlotsCompared-1} 
\SVGLink{TSPlotsCompared-2} 
\end{center} 
\end{exhibit} 
 
\section{Smoothing of a time series using moving averages} 
 
One simple method for smoothing out a time series in order to expose its behaviour is to smooth out the observed data using  the \Rcmd{filter} command to create a moving average. 
A moving average is often centred, (using the argument \Rarg{sides=2}) but if the series is expected to have no trend, then a backwards only (\Rarg{sides=1})  focus can be taken. We must determine the width of the moving average, usually using odd-numbered widths. 
 
Exhibit~\ref{FilterExample} shows how different amounts of data can be averaged to change the amount of smoothing. 
\begin{exhibit} 
\begin{center} 
\caption{Comparison of different amounts of smoothing a time series.} 
\label{FilterExample} 
<<FilterExample, fig=TRUE>>= 
plot(Nile) 
for(i in 1:4){ 
w=4*i-1 # choose the window (3, 7,11,15) 
lines( (start(Nile)[1]):end(Nile)[1], filter(Nile, rep(1/w, w), sides=1), col=i+2) 
} 
@ 
\SVGLink{FilterExample-1} 
\end{center} 
\end{exhibit} 
 
\section{Checking for stationarity}\label{Stationarity}  
 
\stress{Stationarity} is important for modelling time series. Some descriptive methods also need it. 
The simplest form of \nostressind{stationarity} is when the mean of the series and the variance of the series both remain roughly constant over time, or as explained by Hyndman and Athana-sopou-los (2013), "[a] stationary time series is one whose properties do not depend on the time at which the series is observed". (their book is called Forecasting: Principles and Practice.) 
  
A \stressind{white noise} series of normally distributed data with mean zero and constant variance $\sigma^2$ is the strongest form of stationarity we seek in our modelling. It is the desired outcome for the residuals from any model we fit to time series data. 
 
 
The \Rcmd{Box.test} function tests for non-stationarity. 
<<BoxTest>>= 
Box.test(Nile, lag=20) 
@ 
while several other tests exist in add-on packages which can be accessed by loading the  Rpkg{tseries} and \Rpkgforecast} packages. 
<<ForecastTests>>= 
library(tseries) 
library(forecast) 
adf.test(Nile) 
pp.test(Nile) 
kpss.test(Nile) 
@ 
Each test is looking at a different facet of what might indicate how a series might not be stationary. Check out the null hypothesis and alternative for each test on its help page. 
 
 
%% diff() 
 
\section{Autocorrelation and partial autocorrelation} 
 
% check out the Box.test() command. 
 
The autocorrelation and partial autocorrelation function values can be obtained using the \Rcmd{acf} and \Rcmd{pacf} commands. Plotting these is a common way to determine if any of the values found are of interest in understanding the process being modelled so this is the default action performed by these commands. See Exhibit~\ref{NileACF} for the plot generated by the \Rcmd{acf} command. The \Rcmd{pacf} command functions in the same way so is not demonstrated. 
\begin{exhibit} 
\begin{center} 
\caption{Autocorrelation function for the annual flow of the River Nile.} 
\label{NileACF} 
<<NileACF, fig=T>>= 
acf(Nile) 
@ 
\SVGLink{TimeSeriesNileACF-1} 
\end{center} 
\end{exhibit} 
 
To obtain the values of the autocorrelation function (or partial autocorrelation function) in text form, we add an argument to stop the results being plotted. 
<<NileACFNoPlot>>= 
acf(Nile, plot=FALSE) 
pacf(Nile, plot=FALSE) 
@ 
 
\section{Decomposition into seasonal and trend components} 
 
The basic idea of the decompositions presented in this section is to explain the observed time series values $y_t$ in terms of a trend $T_t$, a seasonal component $S_t$ and residual error. 
 
Obviously we need a series that has a seasonal component such as the Australian resident numbers measured quarterly from  1971 to 1994. 
<<getAustResData>>= 
str(austres) 
@ 
 
 
The \Rcmd{decompose} function can create two forms of the decomposition, one of which is additive and the other is multiplicative. 
<<DecomposeAustRes, fig=TRUE>>= 
AustRes.dec1 = decompose(austres) 
Aust.dec2 =decompose(austres, type="mul") 
@ 
The Rcmd{stl} command uses loess smoothing to estimate the trend component before finding the seasonal components and the resulting error terms, and is a slightly more advanced process than that offered by \Rcmd{decompose(}. N.B. there is an \Rcmd{stl} command in the \Rpkg{stats} package and another in the \Rpkg{forecast} package. We use the simpler one here but need to force \R{} to do so just in case the \Rpkg{forecast} package version has precedence. 
 
<<STLAustRes, fig=TRUE>>= 
AustRes.dec3 = stats::stl(austres, s.window="periodic") 
AustRes.dec3 
plot(AustRes.dec3) 
@ 
 
\section{Exponential smoothing} 
 
Exponential smoothing is a method for making predictions of the next observation in a time series. The next observation is a weighted average of all observations to date, with the most recent given the greatest weight and the oldest ones having the least impact. This simple version is useful for situations with no seasonal component or systematic trend component. 
 
Note that this is often expressed as $$\hat{y}_{t+1} = \lambda \hat{y}_{t} + (1-\lambda)y_{t}$$ 
Substituting for $\hat{y}_t$ in terms of terms at time ***t-1*** shows how older values from the observed series contribute smaller and smaller amounts to the new prediction. 
 
The \Rcmd{HoltWinters} command is used for a wide range of models that include the exponential smoother above and allows for trend and seasonality components to be introduced. 
Starting with the Nile data: 
 
<<NileHoltWinters, fig=TRUE>>= 
Nile.hw1 = HoltWinters(Nile, beta=FALSE, gamma = FALSE) 
Nile.hw1 
plot(Nile.hw1) 
@   
Note that we must explicitly set \Rarg{beta} and \Rarg{gamma} to \Rarg{FALSE} to get the simple exponential smoother. 
 
 
Adding a linear trend is fairly simple, but the seasonal component can be expressed as either an additive or a multiplicative term. The two forms would be 
$$y_t = \mu_t + \beta_t t +S_{t-p} + e_t$$ 
and 
$$y_t = (\mu_t + \beta_t t) S_{t-p} + e_t$$ 
respectively , where the $\mu_t$ is found using a deseasonalised version of the simple exponential smoother 
$$\mu_t = \alpha (y_t - S_{t-p}) + (1-\alpha) (\mu_{t-1} + \beta_{t-1})$$ 
for the additive model and 
$$\mu_t = \alpha \frac{y_t }{ S_{t-p}} + (1-\alpha) (\mu_{t-1} + \beta_{t-1})$$ 
for the multiplicative model. 
 
<<AustResHW, fig=TRUE>>= 
AustRes.hw1 = HoltWinters(austres) 
AustRes.hw1 
plot(AustRes.hw1) 
AustRes.hw2 = HoltWinters(austres, seasonal="mult") 
AustRes.hw2 
plot(AustRes.hw2) 
@ 
 
 
 
 
 
 
\section{Autoregressive models} 
 
ar() 
 
\section{Basic ARIMA models} 
 
ARIMA models require the autoregressive and moving average components to be built on a stationary series. We often need to create a stationary series using differencing as seen in Section~\ref{Stationarity} above. 
arima() 
 
\section{Seasonality and ARIMA modelling} 
 
<<cleanup, include=FALSE>>=
rm(list = ls())
@
